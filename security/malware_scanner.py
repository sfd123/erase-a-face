"""
Malware scanning functionality for uploaded files.

This module provides basic malware detection using file signatures,
entropy analysis, and suspicious pattern detection.
"""

import os
import hashlib
import logging
from pathlib import Path
from typing import Dict, List, Optional, Tuple
import math
from collections import Counter

logger = logging.getLogger(__name__)


class MalwareDetectionError(Exception):
    """Raised when malware detection fails."""
    pass


class MalwareScanner:
    """
    Basic malware scanner for uploaded video files.
    
    Performs signature-based detection, entropy analysis,
    and suspicious pattern detection.
    """
    
    # Known malicious signatures (simplified examples)
    MALICIOUS_SIGNATURES = {
        # Common malware signatures (hex patterns)
        b'\x4d\x5a\x90\x00': 'PE_EXECUTABLE',  # PE header
        b'\x7f\x45\x4c\x46': 'ELF_EXECUTABLE',  # ELF header
        b'\xfe\xed\xfa\xce': 'MACH_O_EXECUTABLE',  # Mach-O header
        b'\xca\xfe\xba\xbe': 'JAVA_CLASS',  # Java class file
        b'<script': 'EMBEDDED_SCRIPT',  # Embedded script
        b'javascript:': 'JAVASCRIPT_URI',  # JavaScript URI
        b'vbscript:': 'VBSCRIPT_URI',  # VBScript URI
    }
    
    # Suspicious strings that shouldn't be in video files
    SUSPICIOUS_STRINGS = [
        b'cmd.exe',
        b'powershell',
        b'/bin/sh',
        b'/bin/bash',
        b'eval(',
        b'exec(',
        b'system(',
        b'shell_exec',
        b'passthru',
        b'base64_decode',
        b'CreateObject',
        b'WScript.Shell',
    ]
    
    # Maximum allowed entropy (randomness) for video files
    MAX_ENTROPY = 7.5  # Video files typically have entropy < 7.5
    
    def __init__(self):
        """Initialize malware scanner."""
        self.scan_results_cache: Dict[str, Dict] = {}
    
    def scan_file(self, file_path: Path) -> Dict[str, any]:
        """
        Scan a file for potential malware.
        
        Args:
            file_path: Path to the file to scan
            
        Returns:
            Dictionary with scan results
            
        Raises:
            MalwareDetectionError: If scanning fails
        """
        if not file_path.exists():
            raise MalwareDetectionError(f"File does not exist: {file_path}")
        
        try:
            # Calculate file hash for caching
            file_hash = self._calculate_file_hash(file_path)
            
            # Check cache first
            if file_hash in self.scan_results_cache:
                logger.info(f"Using cached scan results for {file_path}")
                return self.scan_results_cache[file_hash]
            
            # Perform comprehensive scan
            scan_result = {
                'file_path': str(file_path),
                'file_hash': file_hash,
                'file_size': file_path.stat().st_size,
                'is_safe': True,
                'threats_detected': [],
                'warnings': [],
                'scan_details': {}
            }
            
            # 1. Signature-based detection
            signature_results = self._scan_signatures(file_path)
            scan_result['scan_details']['signatures'] = signature_results
            
            if signature_results['threats_found']:
                scan_result['is_safe'] = False
                scan_result['threats_detected'].extend(signature_results['threats'])
            
            # 2. Entropy analysis
            entropy_results = self._analyze_entropy(file_path)
            scan_result['scan_details']['entropy'] = entropy_results
            
            if entropy_results['suspicious']:
                scan_result['warnings'].append(f"High entropy detected: {entropy_results['entropy']:.2f}")
            
            # 3. Suspicious string detection
            string_results = self._scan_suspicious_strings(file_path)
            scan_result['scan_details']['suspicious_strings'] = string_results
            
            if string_results['threats_found']:
                scan_result['is_safe'] = False
                scan_result['threats_detected'].extend(string_results['threats'])
            
            # 4. File structure analysis
            structure_results = self._analyze_file_structure(file_path)
            scan_result['scan_details']['structure'] = structure_results
            
            if structure_results['suspicious']:
                scan_result['warnings'].append("Suspicious file structure detected")
            
            # Cache results
            self.scan_results_cache[file_hash] = scan_result
            
            logger.info(f"Malware scan completed for {file_path}: {'SAFE' if scan_result['is_safe'] else 'THREATS DETECTED'}")
            
            return scan_result
            
        except Exception as e:
            logger.error(f"Malware scan failed for {file_path}: {e}")
            raise MalwareDetectionError(f"Scan failed: {e}")
    
    def _calculate_file_hash(self, file_path: Path) -> str:
        """Calculate SHA-256 hash of file for caching."""
        hash_sha256 = hashlib.sha256()
        with open(file_path, 'rb') as f:
            for chunk in iter(lambda: f.read(4096), b""):
                hash_sha256.update(chunk)
        return hash_sha256.hexdigest()
    
    def _scan_signatures(self, file_path: Path) -> Dict[str, any]:
        """Scan file for known malicious signatures."""
        threats = []
        
        try:
            with open(file_path, 'rb') as f:
                # Read first 1MB for signature scanning
                data = f.read(1024 * 1024)
                
                for signature, threat_type in self.MALICIOUS_SIGNATURES.items():
                    if signature in data:
                        threats.append({
                            'type': 'malicious_signature',
                            'threat': threat_type,
                            'description': f'Malicious signature detected: {threat_type}'
                        })
                        logger.warning(f"Malicious signature detected in {file_path}: {threat_type}")
            
            return {
                'threats_found': len(threats) > 0,
                'threats': threats,
                'signatures_checked': len(self.MALICIOUS_SIGNATURES)
            }
            
        except Exception as e:
            logger.error(f"Signature scan failed for {file_path}: {e}")
            return {
                'threats_found': False,
                'threats': [],
                'error': str(e)
            }
    
    def _analyze_entropy(self, file_path: Path) -> Dict[str, any]:
        """Analyze file entropy to detect packed/encrypted content."""
        try:
            with open(file_path, 'rb') as f:
                # Read sample data for entropy calculation
                sample_size = min(1024 * 1024, file_path.stat().st_size)  # 1MB or file size
                data = f.read(sample_size)
            
            # Calculate Shannon entropy
            entropy = self._calculate_shannon_entropy(data)
            
            return {
                'entropy': entropy,
                'suspicious': entropy > self.MAX_ENTROPY,
                'sample_size': len(data),
                'threshold': self.MAX_ENTROPY
            }
            
        except Exception as e:
            logger.error(f"Entropy analysis failed for {file_path}: {e}")
            return {
                'entropy': 0.0,
                'suspicious': False,
                'error': str(e)
            }
    
    def _calculate_shannon_entropy(self, data: bytes) -> float:
        """Calculate Shannon entropy of data."""
        if not data:
            return 0.0
        
        # Count byte frequencies
        byte_counts = Counter(data)
        data_len = len(data)
        
        # Calculate entropy
        entropy = 0.0
        for count in byte_counts.values():
            probability = count / data_len
            if probability > 0:
                entropy -= probability * math.log2(probability)
        
        return entropy
    
    def _scan_suspicious_strings(self, file_path: Path) -> Dict[str, any]:
        """Scan for suspicious strings that shouldn't be in video files."""
        threats = []
        
        try:
            with open(file_path, 'rb') as f:
                # Read file in chunks to handle large files
                chunk_size = 64 * 1024  # 64KB chunks
                
                while True:
                    chunk = f.read(chunk_size)
                    if not chunk:
                        break
                    
                    # Convert to lowercase for case-insensitive matching
                    chunk_lower = chunk.lower()
                    
                    for suspicious_string in self.SUSPICIOUS_STRINGS:
                        if suspicious_string.lower() in chunk_lower:
                            threats.append({
                                'type': 'suspicious_string',
                                'threat': suspicious_string.decode('utf-8', errors='ignore'),
                                'description': f'Suspicious string found: {suspicious_string.decode("utf-8", errors="ignore")}'
                            })
                            logger.warning(f"Suspicious string detected in {file_path}: {suspicious_string}")
            
            return {
                'threats_found': len(threats) > 0,
                'threats': threats,
                'strings_checked': len(self.SUSPICIOUS_STRINGS)
            }
            
        except Exception as e:
            logger.error(f"Suspicious string scan failed for {file_path}: {e}")
            return {
                'threats_found': False,
                'threats': [],
                'error': str(e)
            }
    
    def _analyze_file_structure(self, file_path: Path) -> Dict[str, any]:
        """Analyze file structure for anomalies."""
        try:
            file_size = file_path.stat().st_size
            
            # Check for suspicious file size patterns
            suspicious = False
            warnings = []
            
            # Very small files claiming to be videos
            if file_size < 1024:  # Less than 1KB
                suspicious = True
                warnings.append("File too small to be a valid video")
            
            # Check file header consistency
            with open(file_path, 'rb') as f:
                header = f.read(32)
                
                # Check if file starts with video magic numbers but has suspicious content later
                if len(header) >= 8:
                    # Basic video format detection
                    is_video_header = (
                        header.startswith(b'\x00\x00\x00') or  # MP4/MOV
                        header.startswith(b'RIFF')  # AVI
                    )
                    
                    if not is_video_header:
                        suspicious = True
                        warnings.append("File header doesn't match expected video format")
            
            return {
                'suspicious': suspicious,
                'warnings': warnings,
                'file_size': file_size
            }
            
        except Exception as e:
            logger.error(f"File structure analysis failed for {file_path}: {e}")
            return {
                'suspicious': False,
                'warnings': [],
                'error': str(e)
            }
    
    def clear_cache(self):
        """Clear the scan results cache."""
        self.scan_results_cache.clear()
        logger.info("Malware scanner cache cleared")
    
    def get_cache_stats(self) -> Dict[str, any]:
        """Get cache statistics."""
        return {
            'cached_results': len(self.scan_results_cache),
            'cache_size_mb': sum(
                len(str(result)) for result in self.scan_results_cache.values()
            ) / (1024 * 1024)
        }


# Global scanner instance
_scanner_instance: Optional[MalwareScanner] = None


def get_malware_scanner() -> MalwareScanner:
    """Get global malware scanner instance."""
    global _scanner_instance
    if _scanner_instance is None:
        _scanner_instance = MalwareScanner()
    return _scanner_instance